'use strict';

function getOffset (evt) {
	var el = evt.target;
	var x = 0;
	var y = 0;

	while (el && !isNaN(el.offsetLeft) && !isNaN(el.offsetTop)) {
		x += el.offsetLeft - el.scrollLeft;
		y += el.offsetTop - el.scrollTop;
		el = el.offsetParent;
	}

	x = evt.clientX - x;
	y = evt.clientY - y;

	return { x: x, y: y };
}

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var StarPlusCanvas = function () {
	function StarPlusCanvas(el) {
		_classCallCheck(this, StarPlusCanvas);

		this.canvas = el;
		this.ctx = this.canvas.getContext('2d');
		this.img = null;
	}

	_createClass(StarPlusCanvas, [{
		key: 'init',
		value: function init(img) {
			this.focalPoints = [];
			this.isPlaying = false;
			if (img.height > window.innerHeight) {
				this.canvas.height = window.innerHeight - 20;
				this.canvas.width = this.canvas.height / img.width * img.height;
			} else {
				this.canvas.width = window.innerWidth - 20;
				this.canvas.height = this.canvas.width / img.width * img.height;
			}

			this.img = img;
			img.style.display = 'none';

			this.canvas.addEventListener('click', this.addPoint.bind(this));

			this.drawImage(img);

			this.detectFaces();
		}
	}, {
		key: 'addPoint',
		value: function addPoint(e) {
			this.ctx.strokeText('x', e.layerX, e.layerY);
			this.focalPoints.push(getOffset(e));
		}
	}, {
		key: 'drawImage',
		value: function drawImage() {
			this.ctx.drawImage(this.img, 0, 0, this.img.width, this.img.height, 0, 0, this.canvas.width, this.canvas.height);
		}
	}, {
		key: 'padFocalPoints',
		value: function padFocalPoints() {
			if (this.focalPoints.length < 10) {
				for (var i = this.focalPoints.length; i < 10; i++) {
					this.focalPoints.push({
						x: Math.random() * this.canvas.width,
						y: Math.random() * this.canvas.height
					});
				}
			}
			return this.focalPoints;
		}
	}, {
		key: 'start',
		value: function start() {
			var _this = this;

			this.isPlaying = true;
			var zConf = this.padFocalPoints().map(function (pt) {
				return {
					ctx: _this.ctx,
					start: pt,
					maxIterations: Math.random() * 150 + 100,
					factor: Math.random() * 0.02 + 1.005
				};
			});

			return this.zoom(zConf[0]).then(function () {
				return _this.filter('brightness(10)', 100);
			}).then(function () {
				return _this.zoom(zConf[1]);
			}).then(function () {
				_this.filter('hue-rotate(50deg)', 400);
				return _this.shake(zConf[2]);
			}).then(function () {
				_this.filter('hue-rotate(-50deg)', 400);
				return _this.zoom(zConf[3]);
			}).then(function () {
				return _this.zoom(zConf[4]);
			}).then(function () {
				_this.filter('invert(100%)', 300);
				return _this.zoom(zConf[5]);
			}).then(function () {
				return _this.shake(zConf[6]);
			}).then(function () {
				_this.filter('brightness(1.2)', 400);
				return _this.zoom(zConf[7]);
			}).then(function () {
				return _this.filter('invert(100%);blur(2px)', 2000);
			}).then(function () {
				return _this.zoom(zConf[8]);
			}).then(function () {
				_this.filter('hue-rotate(120deg)', 400);
				return _this.zoom(zConf[9]);
			});
		}
	}, {
		key: 'stop',
		value: function stop() {
			this.isPlaying = false;
			this.ctx.restore();
		}
	}, {
		key: 'zoom',
		value: function zoom(opts, iterations) {
			var _this2 = this;

			this.ctx.save();
			iterations = iterations || 0;
			var doZoom = function doZoom() {
				if (!_this2.isPlaying) return;
				return new Promise(function (resolve) {
					_this2.ctx.translate(opts.start.x, opts.start.y);
					if (iterations++ < opts.maxIterations / 2) {
						_this2.ctx.scale(opts.factor, opts.factor);
					} else if (iterations < opts.maxIterations) {
						_this2.ctx.scale(1 / opts.factor, 1 / opts.factor);
					} else {
						_this2.ctx.restore();
						return resolve('asda');
					}

					_this2.ctx.translate(-opts.start.x, -opts.start.y);
					_this2.drawImage();
					requestAnimationFrame(function () {
						resolve(doZoom());
					});
				});
			};

			return Promise.resolve(doZoom());
		}
	}, {
		key: 'shake',
		value: function shake(opts, iterations) {
			var _this3 = this;

			this.ctx.save();
			iterations = iterations || 0;
			var doShake = function doShake() {
				if (!_this3.isPlaying) return;
				return new Promise(function (resolve) {
					if (iterations++ < opts.maxIterations) {
						var dx = Math.random() * 10 - 5;
						var dy = Math.random() * 10 - 5;
						_this3.ctx.translate(dx, dy);
						_this3.drawImage();
					} else {
						_this3.ctx.restore();
						return resolve();
					}

					requestAnimationFrame(function () {
						resolve(doShake());
					});
				});
			};

			return Promise.resolve(doShake());
		}
	}, {
		key: 'detectFaces',
		value: function detectFaces() {
			var _this4 = this;

			if (window.FaceDetector == undefined) {
				console.error('Face Detection not supported');
				return;
			}

			var faceDetector = new FaceDetector();
			var scale = this.canvas.width / this.img.width;
			faceDetector.detect(this.img).then(function (faces) {
				// Draw the faces on the <canvas>.
				_this4.ctx.lineWidth = 2;
				_this4.ctx.strokeStyle = 'red';
				var _iteratorNormalCompletion = true;
				var _didIteratorError = false;
				var _iteratorError = undefined;

				try {
					for (var _iterator = faces[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
						var face = _step.value;

						var box = face.boundingBox;
						_this4.ctx.rect(Math.floor(box.x * scale), Math.floor(box.y * scale), Math.floor(box.width * scale), Math.floor(box.height * scale));
						_this4.ctx.stroke();
						_this4.focalPoints.push({
							x: box.x * scale,
							y: box.y * scale
						});
					}
				} catch (err) {
					_didIteratorError = true;
					_iteratorError = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion && _iterator.return) {
							_iterator.return();
						}
					} finally {
						if (_didIteratorError) {
							throw _iteratorError;
						}
					}
				}
			}).catch(function (e) {
				console.error('Boo, Face Detection failed: ' + e);
			});
		}
	}, {
		key: 'filter',
		value: function filter(effect, duration) {
			var _this5 = this;

			if (!this.isPlaying) return;

			return new Promise(function (resolve) {
				_this5.ctx.filter = effect;
				_this5.drawImage();
				setTimeout(function () {
					_this5.ctx.filter = 'none';
					_this5.drawImage();
					return resolve();
				}, duration);
			});
		}
	}, {
		key: 'stream',
		get: function get() {
			return typeof this.canvas.captureStream !== 'undefined' ? this.canvas.captureStream() : null;
		}
	}]);

	return StarPlusCanvas;
}();

var _createClass$1 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AudioPlayer = function () {
	function AudioPlayer() {
		_classCallCheck$1(this, AudioPlayer);

		this.audio = new Audio();
		this.srcset = ['dramatic.mp3', 'dramatic2.mp3', 'dramatic3.ogg'];

		if (typeof AudioContext === 'function') {

			this.ctx = new AudioContext();
			this.audio.oncanplay = this.setUpStream.bind(this);
		}
		this.stream = null;
	}

	_createClass$1(AudioPlayer, [{
		key: 'setUpStream',
		value: function setUpStream() {
			// create a stream from our AudioContext
			var dest = this.ctx.createMediaStreamDestination();
			this.stream = dest.stream;
			// connect our audio element's output to the stream
			var sourceNode = this.ctx.createMediaElementSource(this.audio);
			sourceNode.connect(this.ctx.destination);
			sourceNode.connect(dest);
			this.audio.oncanplay = null;
		}
	}, {
		key: 'start',
		value: function start() {
			var _this = this;

			this.audio.src = this.srcset[Math.floor(Math.random() * 2)];
			this.audio.loop = true;
			this.audio.play();
			return new Promise(function (resolve) {
				_this.audio.addEventListener('canplay', resolve);
			});
		}
	}, {
		key: 'stop',
		value: function stop() {
			this.audio.pause();
			this.audio.currentTime = 0;
		}
	}, {
		key: 'track',
		get: function get() {
			return this.stream.getAudioTracks()[0];
		}
	}]);

	return AudioPlayer;
}();

var _createClass$2 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$2(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*globals MediaRecorder */
var Recorder = function () {
	function Recorder(stream, audioPlayer) {
		_classCallCheck$2(this, Recorder);

		this.stream = stream;
		this.mediaSource = new MediaSource();
		this.mediaRecorder = null;
		this.recordedBlobs = [];
		this.sourceBuffer = null;
		this.audioPlayer = audioPlayer;
	}

	_createClass$2(Recorder, [{
		key: 'start',
		value: function start() {
			var _this = this;

			//reset the recorded blobs
			this.recordedBlobs = [];
			if (this.stream && this.stream.addTrack) {
				this.stream.addTrack(this.audioPlayer.track);
			}

			try {
				var mixedStream = 'MediaStream' in window ? new MediaStream([this.stream.getVideoTracks()[0], this.audioPlayer.track]) : this.stream;
				this.mediaRecorder = new MediaRecorder(mixedStream, { mimeType: 'video/webm;codecs=h264' });
			} catch (e) {
				console.log('MediaRecorder is not supported by this browser', e);
				return;
			}

			//store the data whenever the mediarecorder gives us something
			var handleDataAvailable = function handleDataAvailable(event) {
				if (event.data && event.data.size > 0) {
					_this.recordedBlobs.push(event.data);
				}
			};

			this.mediaRecorder.ondataavailable = handleDataAvailable;

			//start recording
			this.mediaRecorder.start(100);
		}
	}, {
		key: 'stop',
		value: function stop() {
			if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {
				this.mediaRecorder.stop();
			}
		}
	}, {
		key: 'download',
		value: function download() {
			var blob = new Blob(this.recordedBlobs);
			var url = window.URL.createObjectURL(blob);
			var a = document.createElement('a');
			a.style.display = 'none';
			a.href = url;
			a.download = 'star-plus-' + new Date().getTime() + '.mp4';
			document.body.appendChild(a);
			a.click();
			setTimeout(function () {
				document.body.removeChild(a);
				window.URL.revokeObjectURL(url);
			}, 100);
		}
	}]);

	return Recorder;
}();

function imageLoader (el, onLoadFn) {
	var img = new Image();

	el.addEventListener('change', function (e) {
		var reader = new FileReader();
		reader.onload = function (event) {

			img.onload = function () {
				onLoadFn(img);
			};
			img.src = event.target.result;
		};
		reader.readAsDataURL(e.target.files[0]);
	}, false);
}

var init = function init() {

	var mainEl = document.body;
	var canvasEl = document.getElementById('c');
	var imageLoaderEl = document.getElementById('imageLoader');
	var startBtn = document.getElementById('start');
	var stopBtn = document.getElementById('stop');
	var downloadBtn = document.getElementById('download');

	var spCanvas = new StarPlusCanvas(canvasEl);
	var audioPlayer = void 0,
	    recorder = void 0;

	imageLoader(imageLoaderEl, function (img) {
		mainEl.classList.remove('done');
		mainEl.classList.remove('playing');
		mainEl.classList.add('image-loaded');
		spCanvas.init(img);
	});

	var stop = function stop() {
		mainEl.classList.remove('image-loaded');
		mainEl.classList.remove('playing');
		mainEl.classList.add('done');
		spCanvas.stop();
		audioPlayer && audioPlayer.stop();
		recorder && recorder.stop();
		downloadBtn.classList.add('show');
	};

	startBtn.addEventListener('click', function () {
		audioPlayer = new AudioPlayer();
		recorder = new Recorder(spCanvas.stream, audioPlayer);
		audioPlayer.start().then(recorder.start.bind(recorder));
		mainEl.classList.remove('image-loaded');
		mainEl.classList.remove('done');
		mainEl.classList.add('playing');
		spCanvas.start().then(stop);
		downloadBtn.classList.remove('show');
	});

	stopBtn.addEventListener('click', stop);

	downloadBtn.addEventListener('click', function () {
		recorder.download();
	});
};

var registerWorker = function registerWorker() {
	if ('serviceWorker' in navigator) {
		navigator.serviceWorker.register('/star-plus/worker.js');
	}
};

init();
registerWorker();
